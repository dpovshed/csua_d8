<?php

/**
 * @file
 *
 * Main file of the AES encryption module.
 */

// Set phpseclib to use its internal implementation even if mcrypt is available.
define("CRYPT_AES_MODE", 1);

use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_permission().
 */
function aes_permission() {
  return array(
    'administer aes' => array(
      'title' => t('Administer AES'),
      'description' => t('Administer AES module.'),
    ),
  );
}

function aes_load_phpsec() {

  // Find out where this module is located and set up an include path for the phpsec library.
  if (\Drupal::moduleHandler()->moduleExists('libraries') && libraries_get_path('phpseclib')) {
    $phpsec_include_path = libraries_get_path('phpseclib');
  }
  else {
    return -4;
  }

  // Include phpsec AES lib.
  if (file_exists($phpsec_include_path . '/Crypt/AES.php') === FALSE) {
    return -2;
  }
  if (is_readable($phpsec_include_path . '/Crypt/AES.php') === FALSE) {
    drupal_set_message(t("It appears that phpseclib is installed in the right location but can't be read. Check that the permissions on the directory and its files allows for reading by the webserver."));
    return -3;
  }
  if (function_exists("set_include_path") == FALSE) {
    // If we don't have set_include_path then we're out of luck.
    return -1;
  }
  set_include_path(get_include_path() . PATH_SEPARATOR . $phpsec_include_path);
  include_once('Crypt/AES.php');
  return TRUE;
}

function aes_config() {
  $config = \Drupal::config('aes.settings');

  $phpseclib_error_msg = "";

  $phpsec_load_result = aes_load_phpsec();
  $phpsec_loaded = FALSE;
  if ($phpsec_load_result > 0) {
    $phpsec_loaded = TRUE;
  }
  elseif ($phpsec_load_result == -1) {
    // Missing set_include_path.
    $phpseclib_error_msg = " <span style=\"color:#f00;\">" . t("Warning: phpseclib was found but can't be loaded since this sever doesn't allow setting the PHP include path.") . "</span>";
  }
  elseif ($phpsec_load_result == -2) {
    // Couldn't find phpseclib - don't output anything since this is perfectly normal if using mcrypt.
  }
  elseif ($phpsec_load_result == -3) {
    // Found phpseclib, but couldn't read its files.
    $phpseclib_error_msg = " <span style=\"color:#f00;\">" . t("Warning: phpseclib was found but couldn't be read, check permissions.") . "</span>";
  }

  $form = array();

  $form['aes'] = array(
    '#type' => 'fieldset',
    '#title' => t('AES settings'),
    '#collapsible' => FALSE,
  );

  $encryption_implementations = array();
  if ($phpsec_loaded) {
    $encryption_implementations["phpseclib"] = t("PHP Secure Communications Library (phpseclib)");
  }
  if (extension_loaded("mcrypt")) {
    $encryption_implementations["mcrypt"] = t("Mcrypt extension");
  }

  if (!empty($encryption_implementations["mcrypt"]) && !empty($encryption_implementations["phpseclib"])) {
    $implementations_description = t("The Mcrypt implementation is the (only) implementation this module used until support for phpseclib was added. The Mcrypt implementation is faster than phpseclib and also lets you define the cipher to be used, other than that, the two implementations are equivalent.");
  }
  elseif (!empty($encryption_implementations["mcrypt"]) && empty($encryption_implementations["phpseclib"])) {
    $implementations_description = t("The Mcrypt extension is the only installed implementation.") . $phpseclib_error_msg;
  }
  elseif (empty($encryption_implementations["mcrypt"]) && !empty($encryption_implementations["phpseclib"])) {
    $implementations_description = t("PHP Secure Communications Library is the only installed implementation.");
  }

  if (empty($encryption_implementations)) {
    $encryption_implementations = array(t('None!'));
    drupal_set_message(t("You do not have an AES implementation installed!"), "error");
  }

  $form['aes']['aes_implementation'] = array(
    '#type' => 'select',
    '#title' => t('AES implementation'),
    '#options' => $encryption_implementations,
    '#default_value' => $config->get("implementation"),
    '#description' => $implementations_description,
  );

  if ($config->get("implementation") == "phpseclib") {
    $cipher_select_value = "rijndael-128";
    $cipher_select_disabled = TRUE;
    $cipher_description = t("Cipher is locked to Rijndael 128 when using the phpseclib implementation.");
  }
  else {
    $cipher_select_value = $config->get("cipher");
    $cipher_select_disabled = FALSE;
    $cipher_description = "";
  }

  $form['aes']['aes_cipher'] = array(
    '#type' => 'select',
    '#title' => t('Cipher'),
    '#options' => array(
      'rijndael-128' => 'Rijndael 128',
      'rijndael-192' => 'Rijndael 192',
      'rijndael-256' => 'Rijndael 256',
    ),
    '#default_value' => $cipher_select_value,
    '#disabled' => $cipher_select_disabled,
    '#description' => $cipher_description,
  );

  $form['aes']['aes_key'] = array(
    '#type' => 'password',
    '#title' => t('Key'),
    '#description' => t("The key for your encryption system. You normally don't need to worry about this since this module will generate a key for you if none is specified. However you have the option of using your own custom key here."),
  );

  $form['aes']['aes_key_c'] = array(
    '#type' => 'password',
    '#title' => t('Confirm key'),
  );

  $form['aes']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  return $form;
}

function aes_config_validate($form, &$form_state) {

  if (empty($form_state['values']['aes_implementation'])) {
    form_set_error("aes_implementation", t("AES needs an encryption implementation to function. See the README.txt for instructions on how to install one."));
  }

  if (!empty($form_state['values']['aes_key'])) {
    if ($form_state['values']['aes_key'] !== $form_state['values']['aes_key_c']) {
      form_set_error("aes_key", t("The encryption keys didn't match."));
    }
  }

}

/**
 * @param $form
 * @param FormStateInterface $form_state
 *
 * @todo: invoke own hook to notify about key change
 */
function aes_config_submit($form, $form_state) {
//  FormStateInterface;
  var_dump($form_state->getValue('aes_cipher'));
  $config = \Drupal::config('aes.settings');

  // If the cipher has changed...
  $old = $config->get("cipher");
  $new = $form_state->getValue('aes_cipher');
  if ($form_state->getValue('aes_cipher') != $config->get("cipher")) {
    $old_cipher = $config->get("cipher");
    $config->set("cipher", $form_state->getValue('aes_cipher'));
    $new_cipher = $form_state->getValue('aes_cipher');

    // Get the old iv.
    $old_iv = $config->get("mcrypt_iv");
    // update the cipher the system uses
    $config->set("cipher", $form_state->getValue('aes_cipher'));
    // create a new iv to match the new cipher
    aes_make_iv();
    // get the new iv
    $new_iv = $config->get("mcrypt_iv");
  }

  // If the key has changed...
  $new_key = $form_state->getValue('aes_key');
  if (!empty($new_key)) {
    $old_key = aes_get_key();
    $config->set('key', $new_key);

    drupal_set_message(t("Key changed."));
    // @todo: invoke hook?
  }

  // If the implementation has changed...
  if ($form_state->getValue('aes_implementation') != $config->get("implementation")) {

    $config->set("implementation", $form_state->getValue('aes_implementation'));

    if ($form_state->getValue('aes_implementation') == "phpseclib") {
      // If we have switched to phpseclib implementation, set the cipher to 128, since it's the only one phpseclib supports.
      $config->set("cipher", "rijndael-128");
      // Create a new IV, this IV won't actually be used by phpseclib, but it's needed if the implementation is switched back to mcrypt.
      aes_make_iv(TRUE);
    }
  }
  $config->save();
}

function watchdog() {}

function aes_get_key() {
  $key = \Drupal::config('aes.settings')->get("key");
  if (empty($key)) {
    $key = aes_make_key();
    \Drupal::config('aes.settings')->set("key", $key)->save();
    watchdog("aes", "AES module made a new key since one couldn't be found.");
  }
  return $key;
}

function aes_make_key() {

  $acceptable = FALSE;

  $chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";

  while ($acceptable === FALSE) {

    $key = "";

    while (strlen($key) < 32) {
      $key .= substr($chars, rand(0, strlen($chars)), 1);
    }

    $acceptable = TRUE;

    // is there at least one lowercase letter?
    $result = preg_match("/.*[a-z].*/", $key);

    if ($result == 0) {
      $acceptable = FALSE;
    }

    // is there at least one uppercase letter?
    $result = preg_match("/.*[A-Z].*/", $key);

    if ($result == 0) {
      $acceptable = FALSE;
    }

    // is there at least one numeric?
    $result = preg_match("/.*[0-9].*/", $key);

    if ($result == 0) {
      $acceptable = FALSE;
    }
  }

  return $key;
}

function aes_make_iv($ignore_implementation = FALSE) {
  $config = \Drupal::config('aes.settings');

  // Bail out if using phpseclib
  if ($config->get("implementation") == "phpseclib" && $ignore_implementation == FALSE) {
    watchdog("aes", "Called aes_make_iv when using phpseclib. This is harmless, but shouldn't happen.", array(), WATCHDOG_WARNING);
    return;
  }

  if (strtoupper(substr(PHP_OS, 0, 3)) === "WIN") {
    $randgen = MCRYPT_RAND;
  }
  else {
    $randgen = MCRYPT_DEV_URANDOM;
  }

  $td = mcrypt_module_open($config->get("cipher"), "", MCRYPT_MODE_CBC, "");
  $iv = mcrypt_create_iv(mcrypt_enc_get_iv_size($td), $randgen);
  mcrypt_module_close($td);
  $config->set("mcrypt_iv", base64_encode($iv))->save();
}

/**
 * Encrypts a string.
 *
 * @param string $string
 *   The string to encrypt.
 * @param bool $base64encode
 *   Whether to return the string base64 encoded (recommended for database insertion).
 * @param string $custom_key
 *   Use this as the key rather than the stored one for this operation.
 * @param string $custom_cipher
 *   Use this cipher rather than the default one. (only with Mcrypt - ignored with phpseclib)
 * @param string $custom_iv
 *   Use this initialization vector instead of the default one.
 * @param string $force_implementation
 *   Can be "phpseclib" or "mcrypt". Warning: Does not check if the requested implementation actually exists.
 *
 * @return bool|string
 *   The encrypted string on success, false on error.
 */
function aes_encrypt($string, $base64encode = TRUE, $custom_key = NULL, $custom_cipher = NULL, $custom_iv = NULL, $force_implementation = NULL) {
  $config = \Drupal::config('aes.settings');

  // Bail out if the passed string is empty.
  if (empty($string)) {
    watchdog("aes", "Tried to encrypt an empty string.", array(), WATCHDOG_WARNING);
    return FALSE;
  }

  if ($custom_cipher != NULL) {
    $cipher = $custom_cipher;
  }
  else {
    $cipher = $config->get("cipher");
  }

  if (!empty($custom_key)) {
    $key = $custom_key;
  }
  else {
    $key = aes_get_key();
  }

  if (is_null($force_implementation) == FALSE && ($force_implementation == "mcrypt" || $force_implementation == "phpseclib")) {
    $implementation = $force_implementation;
  }
  else {
    $implementation = $config->get("implementation");
  }

  if ($implementation == "phpseclib") {
    // Using phpseclib implementation.

    // phpseclib doesn't support custom ciphers and iv's.
    if (is_null($custom_cipher) == FALSE) {
      watchdog("aes", "A custom cipher was defined when encrypting a string in the AES module using the phpseclib implementation. This implementation doesn't support custom ciphers therefore the argument was ignored and the encryption was done with the standard cipher.", array(), WATCHDOG_WARNING);
    }
    if (is_null($custom_iv) == FALSE) {
      watchdog("aes", "A custom IV was defined when encrypting a string in the AES module using the phpseclib implementation. This implementation doesn't support custom IV's therefore the argument was ignored and the encryption was done with the standard IV.", array(), WATCHDOG_WARNING);
    }

    aes_load_phpsec();
    $phpsec = new Crypt_AES();
    $phpsec->setKey($key);
    $encrypted = $phpsec->encrypt($string);

  }
  else {
    if ($implementation == "mcrypt") {
      // Using mcrypt implementation.
      $td = mcrypt_module_open($cipher, "", MCRYPT_MODE_CBC, "");

      if ($custom_iv == NULL) {
        $iv = base64_decode($config->get("mcrypt_iv"));
      }
      else {
        $iv = base64_decode($custom_iv);
      }

      if (empty($iv)) {
        aes_make_iv();
        $iv = base64_decode($config->get("mcrypt_iv"));
        watchdog("aes", "No initialization vector found while trying to encrypt! This could be a bit of a pain since you might have to reset all the passwords for all users. I've created a new one now and will try to carry on as normal.", array(), WATCHDOG_WARNING);
      }

      $ks = mcrypt_enc_get_key_size($td);

      $key = substr(sha1($key), 0, $ks);

      mcrypt_generic_init($td, $key, $iv);
      $encrypted = mcrypt_generic($td, $string);
      mcrypt_generic_deinit($td);

      mcrypt_module_close($td);
    }
    else {
      $error_msg = t("Request was sent to encrypt a string with the AES module, but the AES module has no active encryption implementation to work with! Did you forget to run update.php after upgrading this module?");

      if (user_access('administer aes')) {
        drupal_set_message($error_msg, "error");
      }
      watchdog("aes", $error_msg, array(), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  if ($base64encode) {
    return base64_encode($encrypted);
  }
  else {
    return $encrypted;
  }
}

/**
 * Decrypts a string of encrypted data.
 *
 * @param string $string
 *   The string to decrypt.
 * @param bool $base64encoded
 *   Whether this encrypted string is base64 encoded or not.
 * @param string $custom_key
 *   Use this as the key rather than the stored one for this operation.
 * @param string $custom_cipher
 *   Use this cipher rather than the default one. (only with Mcrypt - ignored with phpseclib)
 * @param string $custom_iv
 *   Use this initialization vector instead of the default one.
 * @param string $force_implementation
 *   Can be "phpseclib" or "mcrypt". Warning: Does not check if the requested implementation actually exists.
 *
 * @return bool|string
 *   The decrypted string on success, false on error.
 */
function aes_decrypt($string, $base64encoded = TRUE, $custom_key = NULL, $custom_cipher = NULL, $custom_iv = NULL, $force_implementation = NULL) {
  $config = \Drupal::config('aes.settings');

  // Bail out if the passed string is empty.
  if (empty($string)) {
    watchdog("aes", "Tried to decrypt an empty string.", array(), WATCHDOG_WARNING);
    return FALSE;
  }

  if ($base64encoded) {
    $string = base64_decode($string);
  }

  if ($custom_cipher != NULL) {
    $cipher = $custom_cipher;
  }
  else {
    $cipher = $config->get("cipher");
  }

  if (!empty($custom_key)) {
    $key = $custom_key;
  }
  else {
    $key = aes_get_key();
  }

  if (is_null($force_implementation) == FALSE && ($force_implementation == "mcrypt" || $force_implementation == "phpseclib")) {
    $implementation = $force_implementation;
  }
  else {
    $implementation = $config->get("implementation");
  }

  if ($implementation == "phpseclib") {
    // Using phpseclib implementation.

    // phpseclib doesn't support custom ciphers and iv's.
    if (is_null($custom_cipher) == FALSE) {
      watchdog("aes", "A custom cipher was defined when decrypting a string in the AES module using the phpseclib implementation. This implementation doesn't support custom ciphers therefore the argument was ignored and the decryption was done with the standard cipher.", array(), WATCHDOG_WARNING);
    }
    if (is_null($custom_iv) == FALSE) {
      watchdog("aes", "A custom IV was defined when decrypting a string in the AES module using the phpseclib implementation. This implementation doesn't support custom IV's therefore the argument was ignored and the decryption was done with the standard IV.", array(), WATCHDOG_WARNING);
    }

    aes_load_phpsec();
    $phpsec = new Crypt_AES();
    $phpsec->setKey($key);
    $decrypted = $phpsec->decrypt($string);
  }
  else {
    if ($implementation == "mcrypt") {
      // Using mcrypt implementation.

      $td = mcrypt_module_open($cipher, "", MCRYPT_MODE_CBC, "");
      $ks = mcrypt_enc_get_key_size($td);

      if ($custom_iv == NULL) {
        $iv = base64_decode($config->get("mcrypt_iv"));
      }
      else {
        $iv = base64_decode($custom_iv);
      }

      if (empty($iv)) {
        watchdog("aes", "No initialization vector found while trying to decrypt. Aborting!", array(), WATCHDOG_ERROR);
      }

      $key = substr(sha1($key), 0, $ks);

      mcrypt_generic_init($td, $key, $iv);
      $decrypted = mdecrypt_generic($td, $string);
      mcrypt_generic_deinit($td);

      mcrypt_module_close($td);
    }
    else {

      $error_msg = t("Request was sent to decrypt a string with the AES module, but the AES module has no active encryption implementation to work with! Did you forget to run update.php after upgrading this module?");

      if (user_access('administer aes')) {
        drupal_set_message($error_msg, "error");
      }
      watchdog("aes", $error_msg, array(), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  return trim($decrypted);
}
